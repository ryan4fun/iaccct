/**  
 * Copyright (c) IAct Inc. 2000-2009, All rights reserved.
 * @author Andy 
 * File: Tools.java
 * Created: 2012-7-26
 */
package com.iact.util;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Calendar;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileItemFactory;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

import com.iact.ErrorCode;
import com.iact.ResultFile;
import com.iact.IActException;
import com.iact.util.json.JSONException;
import com.iact.util.json.JSONObject;

public class Tools {

	/**
	 * User order id
	 * 
	 * Lock is for controlling multi-thread synchronization, useed is
	 * base-number, we could think it is always different within one day.
	 * 
	 * System.currentTimeMillis / 1000 is current second
	 * 
	 * System.currentTimeMillis() / 1000) % 1000000 is last six number
	 * 
	 */
	private static byte[] ULOCK = new byte[0];
	private static int useed = (int) ((System.currentTimeMillis() / 1000) % 1000000);

	/**
	 * Return a unique <code>ID</code>
	 * 
	 * @return <code>ID</code>
	 */
	public static String getOrderID() {
		String trans = null;
		synchronized (ULOCK) {
			useed = useed + 1;
			if (useed / 100000 > 0) {
				trans = Integer.toString(useed);
			} else if (useed / 10000 > 0) {
				trans = "0" + useed;
			} else if (useed / 1000 > 0) {
				trans = "00" + useed;
			} else if (useed / 100 > 0) {
				trans = "000" + useed;
			} else if (useed / 10 > 0) {
				trans = "0000" + useed;
			} else {
				trans = "00000" + useed;
			}
		}

		Calendar now = Calendar.getInstance();
		String dt = Integer.toString(now.get(Calendar.YEAR))
				+ Integer.toString(now.get(Calendar.MONTH) + 1)
				+ Integer.toString(now.get(Calendar.DATE));
		return dt + trans;
	}

	/**
	 * Transaction id
	 * 
	 */
	private static byte[] TLOCK = new byte[0];
	private static int tseed = (int) ((System.currentTimeMillis() / 1000) % 1000000);

	/**
	 * Return a unique <code>ID</code>
	 * 
	 * @return <code>ID</code>
	 */
	public static String getTransID() {
		String trans = null;
		synchronized (TLOCK) {
			tseed = tseed + 1;
			if (tseed / 100000 > 0) {
				trans = Integer.toString(tseed);
			} else if (tseed / 10000 > 0) {
				trans = "0" + tseed;
			} else if (tseed / 1000 > 0) {
				trans = "00" + tseed;
			} else if (tseed / 100 > 0) {
				trans = "000" + tseed;
			} else if (tseed / 10 > 0) {
				trans = "0000" + tseed;
			} else {
				trans = "00000" + tseed;
			}
		}
		Calendar now = Calendar.getInstance();
		String dt = Integer.toString(now.get(Calendar.YEAR))
				+ Integer.toString(now.get(Calendar.MONTH) + 1)
				+ Integer.toString(now.get(Calendar.DATE));
		return dt + trans;
	}

	/**
	 * User pay one order id generated by web site.
	 * 
	 * Lock is for controlling multi-thread synchronization, pseed is
	 * base-number, we could think it is always different within one day.
	 * 
	 * System.currentTimeMillis / 1000 is current second
	 * 
	 * System.currentTimeMillis() / 1000) % 1000000 is last six number
	 * 
	 */
	private static byte[] PLOCK = new byte[0];
	private static int pseed = (int) ((System.currentTimeMillis() / 1000) % 1000000);

	/**
	 * Return a unique <code>ID</code>
	 * 
	 * @return <code>ID</code>
	 */
	public static String getPayonlineID() {
		String trans = null;
		synchronized (PLOCK) {
			pseed = pseed + 1;
			if (pseed / 100000 > 0) {
				trans = Integer.toString(pseed);
			} else if (pseed / 10000 > 0) {
				trans = "0" + pseed;
			} else if (useed / 1000 > 0) {
				trans = "00" + pseed;
			} else if (useed / 100 > 0) {
				trans = "000" + pseed;
			} else if (useed / 10 > 0) {
				trans = "0000" + pseed;
			} else {
				trans = "00000" + pseed;
			}
		}

		Calendar now = Calendar.getInstance();
		String dt = Integer.toString(now.get(Calendar.YEAR))
				+ Integer.toString(now.get(Calendar.MONTH) + 1)
				+ Integer.toString(now.get(Calendar.DATE));
		return dt + trans;
	}

	private static final String ACTION = "alipay.do";
	private static final String METHOD = "post";
	private static final String BUTTON = "确定";

	public static String buildSBForm(Map<String, String> paramMap) {
		StringBuffer sbHtml = new StringBuffer();

		sbHtml
				.append("<form id=\"alipaysubmit\" name=\"alipaysubmit\" action=\""
						+ ACTION + "\" method=\"" + METHOD + "\">");
		for (String key : paramMap.keySet()) {

			String value = (String) paramMap.get(key);
			sbHtml.append("<input type=\"hidden\" name=\"" + key
					+ "\" value=\"" + value + "\"/>");
		}

		sbHtml.append("<input type=\"submit\" value=\"" + BUTTON
				+ "\" style=\"display:none;\"></form>");
		sbHtml
				.append("<script>document.forms['alipaysubmit'].submit();</script>");

		return sbHtml.toString();
	}

	/**
	 * Return random file name base on current session and current time.
	 * 
	 * @param sessionid
	 * @return
	 */
	public static String getRDFileAbsolutePath(String basePath,
			String sessionid, String suffix) {
		int second = (int) ((System.currentTimeMillis() / 1000) % 1000000);
		String fileName = sessionid + second;

		String realPath = basePath;
		if (realPath.endsWith("/")) {
			return realPath + "images/temp/" + fileName + "." + suffix;
		} else {
			return realPath + "/images/temp/" + fileName + "." + suffix;
		}

	}

	/**
	 * The max size of upload resource image
	 */
	private static final long MAX_SIZE = 300 * 1024;

	/**
	 * File type of allowed upload
	 */
	private static final String[] ALLOWED_EXT = new String[] { "jpg", "jpeg",
			"png", "bmp" };

	public static ResultFile uploadLogo(HttpServletRequest req)
			throws IActException {

		FileItemFactory factory = new DiskFileItemFactory();
		ServletFileUpload fileload = new ServletFileUpload(factory);
		String fileRes = null;
		fileload.setSizeMax(MAX_SIZE);
		try {
			List<FileItem> files = fileload.parseRequest(req);
			if (files != null) {
				for (FileItem item : files) {
					if (item.isFormField()) {
						continue;
					}

					if (item.getSize() > MAX_SIZE) {
						return new ResultFile(ErrorCode.LARGER_THAN_MAX_UPSIZE,
								"上传文件超过" + MAX_SIZE / 1024 + "K");
					}
					String fileName = item.getName();
					String ext = null;
					if (fileName != null) {
						ext = getFileSuffix(fileName);
						boolean allowed = allowedImage(ext);
						if (!allowed) {
							return new ResultFile(ErrorCode.ILLEGAL_FILE_TYPE,
									"上传文件类型" + ext + "不对");
						}
					}
					byte[] logo = item.get();

					String sessionId = req.getSession().getId();
					String basePath = req.getSession().getServletContext()
							.getRealPath("/");

					fileRes = getRDFileAbsolutePath(basePath, sessionId, ext);
					File f = new File(fileRes);
					if (f.exists()) {
						f.delete();
					}
					f = new File(fileRes);
					try {
						f.createNewFile();
					} catch (IOException e1) {
						throw new IActException(e1);
					}

					FileOutputStream out = null;
					try {
						out = new FileOutputStream(f);
						out.write(logo);
					} catch (IOException e) {
						throw new IActException(e);
					} finally {
						if (out != null) {
							try {
								out.flush();
								out.close();
							} catch (IOException e) {
								throw new IActException(e);
							}
						}
					}
					return new ResultFile(fileRes.substring(fileRes
							.lastIndexOf("/") + 1));
				}
			}
		} catch (FileUploadException e) {
			throw new IActException(e);
		}
		return new ResultFile(ErrorCode.ERROR, "未知错误");

	}

	public static boolean allowedImage(String fileExt) {
		for (int i = 0; i < ALLOWED_EXT.length; i++) {
			if (fileExt.equalsIgnoreCase(ALLOWED_EXT[i])) {
				return true;
			}
		}
		return false;
	}

	public static String getFileSuffix(String fileName) {
		int pos = fileName.lastIndexOf(".") + 1;
		String ext = fileName.substring(pos);
		return ext;
	}

}
